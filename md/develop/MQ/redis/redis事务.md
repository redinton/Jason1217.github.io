---
title: redis事务
date: 2020/11/07 17:38:08
toc: true
tags:
- redis
---

关系型数据库ACID 中关于原子性的定义

**原子性**:一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复(Rollback)**到事务开始前的状态**，就像这个事务从来没有执行过一样。
<!--more-->
官方文档对事务的定义：
* 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。**事务在执行的过程中，不会被其他客户端发送来的命**令请求所打断。
* 事务是一个原子操作：事务中的命令要**么全部被执行，要么全部都不执行**。EXEC 命令负责触发并执行事务中的所有命令：如果客户端在使用 MULTI 开启了一个事务之后，**却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行**。另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。

从ACID原子性定义来看，严格意义上讲Redis事务是非原子型的，因为在命**令顺序执行过程中，一旦发生命令执行错误Redis是不会停止执行然后回滚**数据

#### redis事务生命周期：

* 开启事务：使用MULTI开启一个事务
* 命令入队列：每次操作的命令都会加入到一个队列中，但命令此时不会真正被执行
* 提交事务：使用EXEC命令提交事务，开始顺序执行队列中的命令

#### Redis 为什么不支持Rollback

在**事务运行期间**虽然Redis命令可能会执行失败，但是Redis依然**会执行事务内剩余的命令而不会执行回滚**操作

> 只有当被调用的Redis命令有语法错误时，这条命令才会执行失败（在将这个命令放入事务队列期间，Redis能够发现此类问题），或者对某个键执行不符合其数据类型的操作：实际上，这就意味着只有程序错误才会导致Redis命令执行失败，这种错误很有可能在程序开发期间发现，一般很少在生产环境发现。支持事务回滚能力会导致设计复杂，这与Redis的初衷相违背，Redis的设计目标是功能简化及确保更快的运行速度


（1）WATCH

可以为Redis事务提供 check-and-set （CAS）行为。被WATCH的键会被监视，并会发觉这些键是否被改动过了。如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回nil-reply来表示事务已经失败。

（2）MULTI

用于开启一个事务，它总是返回OK。MULTI执行之后,客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行，而是被放到一个队列中，当 EXEC命令被调用时， 所有队列中的命令才会被执行。

（3）UNWATCH

取消 WATCH 命令对所有 key 的监视，一般用于DISCARD和EXEC命令之前。如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了。因为 EXEC 命令会执行事务，因此 WATCH 命令的效果已经产生了；而 DISCARD 命令在取消事务的同时也会取消所有对 key 的监视，因此这两个命令执行之后，就没有必要执行 UNWATCH 了。

（4）DISCARD

当执行 DISCARD 命令时， 事务会被放弃， 事务队列会被清空，并且客户端会从事务状态中退出。

（5）EXEC

负责触发并执行事务中的所有命令：

如果客户端成功开启事务后执行EXEC，那么事务中的所有命令都会被执行。

如果客户端在使用MULTI开启了事务后，却因为断线而没有成功执行EXEC,那么事务中的所有命令都不会被执行。需要特别注意的是：即使事务中有某条/某些命令执行失败了，事务队列中的其他命令仍然会继续执行，Redis不会停止执行事务中的命令，而不会像我们通常使用的关系型数据库一样进行回滚。