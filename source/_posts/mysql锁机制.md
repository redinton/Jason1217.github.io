---
title: mysql锁机制
date: 2020/11/06 10:44:35
toc: true
tags:
- mysql
---


### 乐观锁和悲观锁

悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作

乐观锁：假设不会发生并发冲突，只在**提交操作时检查是否违反数据完整**性。

### MVCC
全称是Multi-Version Concurrent Control，即多版本并发控制，在MVCC协议下，每个读操作会看到一个一致性的snapshot，并且可以实**现非阻塞的读**。MVCC**允许数据具有多个版本**，这个版本可以是时间戳或者是全局递增的事务ID，在同一个时间点，不同的事务看到的数据是不同的。

### MySQL的innodb引擎是如何实现MVCC的
innodb会为每一行添加两个字段，分别表示该行创建的版本和删除的版本，填入的是事务的版本号，这个版本号随着事务的创建不断递增


### 锁机制和事务控制

Innodb提供行级锁，支持共享锁和排它锁两种锁定模式和四种不同的隔离级别.

* 表级锁
  * 开销小，加锁快，不会出现死锁，锁定粒度大，发生锁冲突概率最高，并发度最低
* 行级锁
  * 开销大，加锁慢，会出现死锁，锁定粒度小，发生锁冲突概率最低，并发度最高
* 页面锁
  * 开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般  
<!--more-->
应用
* 表级锁更适合于以查询为主，只有**少量按索引条件更新数据**的应用，如Web 应用
* 行级锁则更适合于有**大量按索引条件并发更新少量不同**数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统


#### 表级锁
MyISAM只支持表锁，MySQL表级锁有两种模式
* 表共享读锁 table read lock
  * 对MyISAM 表的读操作，**不会阻塞其他用户对同一表的读**请求，但**会阻塞对同一表的写**请求；
* 表独占写锁 table write lock
  * 写操作，则会阻塞其他用户对同一表的读和写操作  


MyISAM 表的读操作与写操作之间，以及写操作之间是串行的！
一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。


* MyISAM锁调度
  * MyISAM 存储引擎的读锁和写锁是互斥的，读写操作是串行
  * 一个进程请求某个MyISAM 表的读锁，同时另一个进程也请求同一表的写锁
    * 写进程先获得锁。不仅如此，即使读请求先到锁等待队列，写请求后到，写锁也会插到读锁请求之前。


#### 行级锁
InnoDB采用行级锁。
脏读，不可以重复读，幻读都是数据库读一致性的问题，必须由数据库提供一定的事务隔离机制来解决。  
数据库实现事务隔离方式
* 读取数据前，对其加锁，阻止其他事务对数据进行修改
* 不加锁 通过一定机制生成一个数据请求时间点的**一致性数据快照**（Snapshot)，并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度来看，好象是数据库可以提供同一数据的多个版本，因此，这种技术叫做数据多版本并发控制(MultiVersion Concurrency Control，简称**MVCC** 或MCC），也经常称为多版本数据库

两种类型的行锁
* 共享锁(S)
  * 允许一个事务读一行，阻止其他事务获得相同数据集的排他锁
* 排他锁(X)
  * 允许获得排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他写锁

意向锁是InnoDB 自动加的，不需用户干预。对于UPDATE、DELETE 和INSERT 语句，InnoDB会自动给涉及数据集**加排他锁**（X)；对于普通SELECT 语句，InnoDB 不会加任何锁；事务可以通过以下语句显示给记录集加共享锁或排他锁。

* 共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。
* 排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。

另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。
* 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。
* 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前
必须先取得该表的 IX 锁。

意向锁是InnoDB 自动加的，不需用户干预。
* 对于UPDATE、DELETE 和INSERT 语句，InnoDB会自动给涉及数据集加排他锁（X)；
* 对于普通SELECT 语句，InnoDB 不会加任何锁；
* 事务可以通过以下语句显示给记录集加共享锁或排他锁。
   * 共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。
  * 排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。

InnoDB行级锁的实现
通过给索引上的索引项加锁，Oracle是通过在数据块中对相应的数据行加锁实现。
只有**通过索引条件检索数据，I**nnoDB才使用行级锁，否则InnoDB使用表锁。

#### 间隙锁 next-key 锁
使用范围条件而非相等条件检索数据,并请求共享或排他锁时，InnoDB会给符合条件的记录的索引项加锁，同时，对键值在条件范围内但不存在的记录，叫做间隙GAP，也会加锁。
```SQL
Select * from emp where empid > 100 for update;
```
表emp中只有id从1,2,...101.对empid大于101(不存在的记录)加锁。

目的
* 防止幻读，以满足相关隔离级别需要，若没有间隙锁。其他事务插入empid大于100的任何记录，本事务再执行上述语句，就会发生幻读
* 满足其恢复和复制的需要

Innodb这种锁机制会阻塞符合条件范围内键值的并发插入，造成严重的锁等待。针对并发插入操作多的应用，尽量使用相同条件来访问更新数据，避免使用范围条件。

InnoDB针对使用相同条件请求一个不存在的记录**加锁**，也会用间隙锁。<这个就无关事务隔离级别了>
> 本来应该加行锁，变成加间隙锁   
> select * from emp where empid=201 for update;


