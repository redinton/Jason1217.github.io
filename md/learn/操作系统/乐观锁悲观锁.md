---
title: 乐观锁悲观锁
date: 2020/11/04 10:53:36
toc: true
tags:
- develop
---


#### 线程安全
<!--more-->
* 如果一个类被设计为允许多线程正确访问，那么这个类就是 “**线程安全**”
* 对线程安全性的讨论必须建立在对象内部存在共享变量这一前提，若对象在多条线程间**没有共享数据**，那这个对象一定是线程安全的
* 还有一些不变类如 String，Integer，LocalDate 所有成员变量都是final，多线程同时访问时，只能读不能写，因此也是 “线程安全”

* 并发
  * 同一个时间间隔多个请求
* 并行
  * 同一个时刻同时操作

#### 乐观锁和悲观锁
这两个是设计思想。涉及多线程更新共享变量,可以通过加锁保障数据一致性和安全性。
* 悲观锁, 共享资**源每次只给一个线程使用**, 其余线程阻塞. 常见通过**加锁**来保障变量数据的一致性和安全性
  * 例如MySQL的表锁,行锁,python的threading中的Lock


* 乐观锁, **默认不会阻塞其他线程访问操作该对象**(因此不会去加锁), 但是需要**更新的时候去判断该值有没有被其他线程更新**过。 通过**CAS和版本号**来实现乐观锁并发更新。
  * CAS (compare and swap) -- 原子操作
    * 用于多线程中实现不被打断的数据交换操作,避免多线程同时改写某一数据由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题
    * CAS包含三个操作数，内存值V，预期原值A和更新值B，先比较V是否与A相等，相等就把V更新为B，否则返回
      * 缺点1 ABA问题 
        * 一个变量v 被线程读取的时候是A，经过逻辑运算，更新的时候还是A，那么能确保该变量没有被修改过? 比如值从 A-->B-->A ,中间被修改为B,最后又修改为A 
      * 解决
        * 增加版本号的对比。取数据时，同时取出记录的版本号的值，更新的时候 将版本号加一
      * 缺点2
        * 如果并发更新失败，基于CAS的方式会不断循环尝试，给CPU带来压力，影响性能

场景
* 悲观锁
  * 适合写入频繁场景, 若出现大量读取操作，每次读取都进行加锁，会增加开销，降低系统的吞吐量
* 乐观锁
  * 适合读取频繁，若出现大量写入操作，数据发生冲突的可能性变大，为保证数据的一致性，应用层要不断重新获取数据，会增加大量的查询操作，降低系统的吞吐量


[面试必备之乐观锁与悲观锁](https://cloud.tencent.com/developer/article/1628711)