[TOC]



##### 进程和线程的区别

* 多线程和多进程最大的不同
  * 多进程中，同一个变量，各有一份拷贝存在每个进程中，互不影响
  * 多线程中，所有变量由所有线程共享
    * 危险在于多个线程同时改一个变量，内容变乱
    * 解决办法
      * 加锁，运行期间加锁，当多个线程同时执行 lock.acquire() 时，只有一个线程能成功获取锁，好处是确保某段关键代码只能由一个线程从头到尾完整执行，坏处是
        * 1.阻止了多线程并发执行，效率降低
        * 2.由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。

Thread和Process中，优选Process，Process更稳定，且Process可以分布到多台机器上，Thread最多只能分布到同一台机器的多个CPU上



##### 线程占用资源吗



##### 写一个线程池



##### 说一说线程安全



##### bio，nio，aio的区别



##### 同步和异步区别



##### 阻塞和非阻塞的区别





#### 进程调度

* 首先，操作系统需要有控制权，所以就引入`时钟中断`（Clock Interrupt），进程每隔一段时间，将**控制权还给操作系统**，操作系统决定将下次的执行权限赋予哪个进程，这个过程，必须要调度算法协调多方。

* 策略
  * 先进先出，
  * 短任务优先
  * 最短完成时间优先
  * 多级反馈
    * 将任务分优先级，高优先的先执行，每隔一段，中低级的任务都有机会晋升为高优先级任务，避免高优先级任务一直占用 CPU，低优先任务饿死。
  * 比例份额
    * 每个任务都有份额，高优先重要的任务份额多，低优先级的少，每次 CPU 运行权都进行彩票抽奖，这样达到理论上的公平。每个任务还可以将份额再细分给子任务，这样能让任务也有控制权。



#### 内存虚拟化

操作系统通过**分段和分页**技术抽象了地址空间，所以进程里的内存地址是虚拟的。**每个进程运行的时候，都拥有一块非常大的虚拟地址空间**，像独占了整个进程一样。它实现了进程之间的隔离，也让每个进程最大化利用内存。

* 分段

  * 一般内存分为 4 个部分，程序代码，堆，栈，空闲地址。

  * 运行的时候程序代码是固定的，所以放在最上面

  * 堆需要的内容比较大，所以向下增长

  * 栈所需的内容比较少，放在内存的最后部分，反向增长

  * 这样空闲的部分就很大，分段就是将地址空闲地址，分成不同的段，提供空闲地址的利用率。

    ![img](https://pic3.zhimg.com/v2-49bf07299a06dd50406bb63c9f1e0bc6_b.jpg)

* 分页

  * 将虚拟地址转换成物理地址
  * 分页的地址可以是连续的，物理地址可以不连续
  * 分页和物理地址之间，引入了页表，专门管理分页到物理地址的映射。

* 分段是逻辑地址 -> 线性地址（虚拟地址），而分页是虚拟地址 -> 物理空间，

* TLB (translation lookaside buffer TLB)
  * 每一次内存访问，都需要执行一次虚拟地址到真实地址的查找，那 I/O 非常高
  * TLB，一个存储虚拟地址到真实地址的数据结构，也是程序中经常说的缓存