---
title: mysql索引
date: 2020/11/05 10:57:27
toc: true
tags:
- mysql
---

所有mysql列类型都可以被索引。根据engine可以定义每个表的最大索引数和最大索引长度。  
MyiSAM和Innodb表默认都是BTree索引，Mysql支持前缀索引，即对索引字段的前N个字符创建索引
<!--more-->
### 索引的设计

* 经常出现在where中作为筛选条件或者join中作为表连接条件
* 重复值较多的列，索引效果差  
* 字符串类型的索引,最好指定前缀长度,创建短索引, 减少磁盘I/O而且在做比较时性能也更好,MySQL底层的高速索引缓存能够缓存更多的键值.
* 查询条件2个及以上，可以多个单列索引或者一个联合索引,创建包含N列的联合索引(多列索引),利用最左前缀匹配   
当创建 (a,b,c)联合索引时，相当于创建了(a)单列索引，(a,b)联合索引以及(a,b,c)联合索引** 想要索引生效的话,只能使用 a和a,b和a,b,c三种组合；当然，我们上面测试过，a,c组合也可以，但实际上只用到了a的索引，c并没有用到！  
* 不要过度使用索引。索引并不是越多越好，索引需要占用额外的存储空间而且会影响写操作的性能（插入、删除、更新数据时索引也需要更新
* 要注意可能使索引失效的场景，例如：模糊查询使用了前置通配符 like %...

BTree索引
当使用比较操作符(>,<,>=,<=,!=,<>),between,like 'pattern'(pattern不以通配符开始), 可以使用上述相关列索引



####  索引的分类

* 普通索引
  * 直接创建: create index index_name on table(column(length))
  * 修改表结构添加: alter table add index index_name on (column(length))
  * 创建表的过程中直接创建
* 唯一索引
  * 索引列的值必须唯一，但允许空值，如果是组合索引，则列值的组合必须是唯一的
  * 直接创建 create unique index index_name on table(column(length))
  * 修改表结构 alter table add unique index index_name on (column(length))
* 组合索引
  * 多个字段上创建的索引



#### 索引的缺点

* 虽然加快查询的速度，但同时也降低更新的速度， insert，update，delete
* 建索引会占用磁盘空间的索引文件。 一般不严重，但如果在一个表上创建了多种组合索引，索引文件增长会非常快



#### mysql建索引规则

* 主键，外键必须
* 数据量超过300必须
* 经常与其他表join的表，join字段应该
* 经常出现在where子句中的字段
* 索引应该建立在小字段上
* 复合索引建立要慎重
* 频繁数据操作的表，不用建太多的索引


### 聚簇索引 & 非聚簇索引
区别在于**叶节点是否存放一整行**记录。
* InnoDB 主键用的是聚簇索引
* MyISAM 不管是主键索引还是二级索引都是非聚簇索引

非聚簇索引
* 表数据和索引分成两部分存储,叶子结点索引节点，有指向对应数据块的指针

聚簇索引 
* 表数据和主键一起存储，主键索引的叶节点存储行数据，包括主键值
* 二级索引的叶结点存储行的主键值
* 优点
  * 取出一定范围内的数据，聚簇索引更好
  * 理论上聚簇索引查找目标数据比非聚簇索引更快，因为非聚簇索引定位到主键还要多一次I/O取数据
* 缺点
  * 插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一**个自增的ID列为主键**
  * 更新主键的代价很高，因为将会导致被更新的行移动
  * 二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。**二级索引的叶节点存储的是主键值**，而不是行指针（**非聚簇索引存储的是指针或者说是地址**），这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间

#### B+树的搜索次数、为什么不用二叉树，为什么不用哈希表，不用B树

* 不用哈希表
  * 哈希表虽然更快，但是Hash 索引仅仅能满足”=”,”IN”和”<=>”查询， **不支持范围查询**
  * Hash索引不能用**来优化排序**操作
  * 在有大量重复键值情况下，因为存在哈希碰撞，所以哈希索引效率也低
* 不用二叉树
  * AVL 树（平衡二叉树）和红黑树（二叉查找树）基本都是存储在内存中才会使用的数据结构
  * 大规模数据存储的时候，红黑树往往出现由于**树的深度过大而造成磁盘IO读写过于频繁**，进而导致效率低下的情况
  * 磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。根据磁盘查找存取的次数往往由树的高度所决定
* 不用B树
  * B 树能够**在非叶节点中存储数据**，但是这也导致在**查询连续数据时**可能会带来更多的随机I/O
  * B+ 树的所**有叶节点可以通过指针相互连接**，能够减少顺序遍历时产生的额外随机 I/O

#### B+树索引中树的高度

* B+树索引特点是高扇出性,数据库中B+树的高度2-3层,意味着查找某个key的记录, 最多只需要2到3次IO开销
* 数据库中的B+树索引
  * clustered index(聚簇索引) 区分是该类型叶节点存放整行记录。 每张表只能有一个聚集索引(一个主键)
  * secondary index(非聚簇索引)
* InnoDB Engine默认一个数据页大小16kb,非叶子节点存放(key,pointer),pointer为6个字节，key为8个字节(bigint类型),那么一个非叶子结点能存放16kb / 14个key。
  * 叶子节点假设数据100Byte，一个叶子结点16kb/100 为160条数据
  * 如果高度为3的话, 可存放数据 16kb/14 * 16kb/14 * 160 约一亿条