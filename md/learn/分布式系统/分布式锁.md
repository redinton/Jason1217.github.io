---
title: 分布式锁
date: 2020/11/30 17:34:36
toc: true
tags:
- redis
- 分布式
---

最低保证分布式锁的有效及安全性
* 互斥: 任何时刻只能有一个client获取锁
* 释放死锁: 即便锁定资源的服务崩溃或者分区, 仍能释放锁 (给锁设置过期时间)
  * 即便一个客户端持有锁的期间崩溃而没有主动释放锁，需要保证后端其他客户端能加锁成功
* 容错性:只要多数节点在使用，client就可以获取和释放锁
<!--more-->
#### redis单节点分布式锁

* 设置锁，使用set，包含setnx,expire，起到原子操作
  * key设置随机值,只有在key不存在时，才设置成功返回True，并设置key的过期时间
    ```bash
    SET key_name my_random_value NX PX 30000 
    # key_name由业务逻辑决定，保证唯一性
    # NX 表示if not exist 就设置并返回True，否则不设置并返回False
    # PX 表示过期时间用毫秒级， 30000 表示这些毫秒时间后此key过期
    ```
* 获取锁，完成业务逻辑后，要删除自己设置的锁(锁只能被设置的人删除)
  * 删除方法用Lua脚本(该脚本可以保证删除锁操作的原子性)
  * 逻辑是先获取key,如果存在并且值是自己就删除此key; 否则跳过。


##### 超时解锁导致的并发
如果线程 A 成功获取锁并设置过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁，线程 A 和线程 B 并发执行.  
解决方式
* 过期时间设置足够长，确保代码逻辑在锁释放之前能够执行完成。
* 获取锁的线程增加守护线程，为**将要过期但未释放的锁增加有效**时间

#### redis多节点分布式锁
RedLock算法
奇数个的独立redis服务器
* 获取当前时间戳
* client用相同的key 按照顺序去每个redis里请求锁,一般会设置从某个redis获取锁的时间上限，当超过时，就会放弃尝试获取该redis上的锁，原因是为了不要过长时间等待已经关闭的redis服务
  * 这个时间一般会小于锁过期的时间
* client获取所有能获取的锁后的时间减去第一步的时间戳，时间间隔小于锁的TTL(time to live)并且至少有三个redis实例成功获取锁，才算真正获取锁成功
* 如果获取锁成功,锁的真正有效时间就是TTL减去上一步计算的client获取所有能获取的锁耗费的总时长
* 如果client获取锁失败，便会开始解锁所有redis实例，因为可能已经获取小于三个锁，必须释放，否则可能会影响其他client获取锁。

RedLock失败重试
* 当client获取锁失败后，应该在随机时间重试获取锁，并且最好在同一时刻并发把set命令发送给所有redis实例
RedLock注意点
* 假设client获取所有redis实例，所有实例包含相同的key和TTL，但由于每个实例set命令时间不同导致不能同时过期，假设第一个set命令之前是T1，最后一个set命令是T2，则此client有效获取锁的最小时间是 TTL - (T2-T1) - 时钟漂移
* 一半以上方式判断获取锁成功
  * 因为如果小于一半，则可能出现多个client成功获取锁的情况，锁就失效了
* 如果一个client锁定大多数实例耗费的时间大于或接近锁的TTL，则认为锁无效，并且解锁这个redis实例(不执行业务)