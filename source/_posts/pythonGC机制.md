---
title: pythonGC机制
date: 2020/11/19 10:31:26
toc: true
tags:
- python
---

### 说一说gc/python的垃圾回收机制
* 引用计数
* 标记清除
* 分代回收

<!--more-->
#### 引用计数
python默认的gc机制是引用计数法

* 每个对象维护一个字段记录当前对象被引用的次数，一旦对象引用计数为0，该对象立即被回收，内存空间被释放
* 缺点
  * **无法解决对象的循环引用问题**
    * ```python
      a=[1,2]
      b=[2,3]
      a.append(b)
      b.append(a)
      DEL a
      DEL b
      #a，b的被引用次数都是1 无法被gc
      ```
  * 需要额外的空间维护引用计数
* 引用计数+1的情况
  * 对象被创建  a=23, ; 对象被引用 b = a,
  * 对象被作为参数，传入一个函数 func(a);
  * 对象作为一个元素，被存储到容器中 list = [a]
* 引用计数 - 1
  * 对象别名被显示销毁  del a;
  * 对象别名被赋予新的对象 a = 24
  * 对象离开作用域例如f函数执行完毕后，func中的局部变量(全局变量不会)
  * 对象所在的容器被销毁，或者从容器中删除对象

#### 标记清除

* 用来解决**容器对象**(列表,字典,用户自定义类的对象,元祖等)可能产生的**循环引**用
* 每个容器对象维护两个额外的指针，用来把容器对象组成双端队列，指针分别指向前后两个容器
* Cpython维护两个这种双端队列，
  * 一个链表存放需要被扫描的容器对象
  * 另一个存放着临时不可达对象
* 步骤
  * **标记阶段**-遍历需要被扫描的容器对象的这个链表,并且将当前对象所引用的所有对象的gc_ref减一，这一步操作就相当于解除了循环引用对引用计数的影响。
    * 接着gc会再次扫描所有的容器对象，如果对象的gc_ref值为0，那么这个对象并且被移至”Unreachable”链表。
    * 如果对象的gc_ref不为0，标记为可达的。当gc发现有一个节点是可达的，那么他会递归式的将从该节点出发可以到达的所有节点标记为GC_REACHABLE。
  * **清除阶段**-再次遍历对象,如果发现某个对象没有标记可达,则回收
* 标记清除阶段, 会暂停整个应用程序。等待标记清除结束后才会恢复应用程序的运行。

#### 分代回收
为了**减少应用程序暂停的时间**，“分代回收”(Generational Collection)以空间换时间的方法提高垃圾回收效率。
* 对象存在时间越长，越不可能是垃圾，应该越少去收集
* 在标记-清除可以**有效减少遍历的对象数目**，进而提高垃圾回收的速度
* 将内存根据对象的存活时间分成三个集合，年轻代，中生代，老年代
* 每一个新生对象在generation zero中，如果它在一轮gc扫描中活了下来，那么它将被移至generation one,在那里他将较少的被扫描，如果它又活过了一轮gc,它又将被移至generation two，在那里它被扫描的次数将会更少
* gc的扫描在什么时候会被触发呢?答案是**当某一世代中被分配的对象与被释放的对象之差达到某一阈值**的时候，就会触发gc对某一世代的扫描。值得注意的是当某一世代的扫描被触发的时候，**比该世代年轻的世代也会被扫描**。

[Python垃圾回收机制！非常实用](https://zhuanlan.zhihu.com/p/83251959)

